//@version=6
//@strategy_alert_message {{strategy.order.alert_message}}

strategy("Chained Linear Regression Reversal Strategy",
     shorttitle="Chain LR Strategy",
     overlay=true,
     max_lines_count=500,
     initial_capital=100000,
     default_qty_type=strategy.fixed,
     default_qty_value=1,
     commission_type=strategy.commission.cash_per_contract,
     commission_value=0)

import sacredprofit/Toolbox/2

// ============================================================================
// INPUTS
// ============================================================================

// Time Selection
startTime = input.time(timestamp("2024-01-01 00:00"),
     "Start Time",
     tooltip="Click to select the beginning candle for regression calculation on the chart",
     confirm=true,
     group="Time Selection")

endTime = input.time(timestamp("2024-12-31 23:59"),
     "End Time",
     tooltip="Click to select the ending candle for regression calculation on the chart",
     confirm=true,
     group="Time Selection")

// Regression Settings
ignoreWicks = input.bool(false,
     "Ignore Wicks",
     tooltip="When enabled, uses candle body midpoint (average of open/close) instead of wicks.\n" +
             "This reduces noise from price extremes and focuses on body momentum.\n" +
             "When disabled, uses the 'Price Source' setting below.",
     group="Regression Settings")

priceSource = input.source(close,
     "Price Source",
     tooltip="Price data for regression when 'Ignore Wicks' is disabled.\n" +
             "Options: close, open, high, low, hl2, hlc3, ohlc4, hlcc4.\n" +
             "Note: This setting is ignored when 'Ignore Wicks' is enabled.",
     group="Regression Settings")

regressionMode = input.string("Both",
     "Regression Mode",
     options=["Static", "Live", "Both"],
     tooltip="Static: Show only original regression (solid line, locked at end time)\n" +
             "Live: Show only dynamic updating regression (dashed line, continues beyond end time)\n" +
             "Both: Show both for comparison (static = solid, live = dashed)",
     group="Regression Settings")

showUpperChannel = input.bool(true,
     "Upper Deviation",
     inline="upper",
     group="Regression Settings")

upperDeviation = input.float(3.0,
     "",
     minval=0.1,
     step=0.1,
     inline="upper",
     tooltip="Standard deviation multiplier for upper channel",
     group="Regression Settings")

showLowerChannel = input.bool(true,
     "Lower Deviation",
     inline="lower",
     group="Regression Settings")

lowerDeviation = input.float(3.0,
     "",
     minval=0.1,
     step=0.1,
     inline="lower",
     tooltip="Standard deviation multiplier for lower channel",
     group="Regression Settings")

breakoutConfirmation = input.int(1,
     "Breakout Confirmation Bars",
     minval=1,
     maxval=10,
     tooltip="Number of consecutive closes beyond the channel required to confirm breakout.\n" +
             "The dynamic regression only starts after this many consecutive closes outside the static channel.",
     group="Regression Settings")

lockRThreshold = input.float(0.85,
     "Lock R Threshold",
     minval=0.5,
     maxval=0.99,
     step=0.01,
     tooltip="When the dynamic regression's |Pearson R| drops below this value, it locks as the new static regression.\n" +
             "The system then waits for price to break out of this new channel to start the next dynamic regression.",
     group="Regression Settings")

minBarsBeforeLock = input.int(5,
     "Min Bars Before Lock",
     minval=2,
     maxval=50,
     tooltip="Minimum number of bars the dynamic regression must run before it can lock as a new static.\n" +
             "Prevents premature locking on very short regressions.",
     group="Regression Settings")

maxBarsTimeout = input.int(50,
     "Max Bars Timeout",
     minval=10,
     maxval=500,
     tooltip="If the dynamic regression doesn't reach the R threshold within this many bars,\n" +
             "reset and start a new regression from the current bar.\n" +
             "This prevents the dynamic from running indefinitely without locking.",
     group="Regression Settings")

// Strategy Settings
enableStrategy = input.bool(true,
     "Enable Strategy",
     tooltip="Enable/disable strategy orders. When disabled, only shows the regression lines.",
     group="Strategy Settings")

stopLossPoints = input.float(10.0,
     "Stop Loss (Points)",
     minval=0.1,
     step=0.5,
     tooltip="Stop loss distance in points from entry price.",
     group="Strategy Settings")

takeProfitPoints = input.float(20.0,
     "Take Profit (Points)",
     minval=0.1,
     step=0.5,
     tooltip="Take profit distance in points from entry price.",
     group="Strategy Settings")

// Visual Settings
uptrendColor = input.color(#26a69a,
     "Uptrend Color",
     tooltip="Base color for uptrend (positive slope) regression channels",
     group="Visual Settings")

downtrendColor = input.color(#ef5350,
     "Downtrend Color",
     tooltip="Base color for downtrend (negative slope) regression channels",
     group="Visual Settings")

fillTransparency = input.int(93,
     "Fill Transparency",
     minval=0,
     maxval=100,
     tooltip="Transparency for channel fill (0=opaque, 100=invisible)",
     group="Visual Settings")

lineWidth = input.int(2,
     "Line Width",
     minval=1,
     maxval=5,
     tooltip="Width for all regression and channel lines",
     group="Visual Settings")

showStatsTable = input.bool(false,
     "Show Statistics Table",
     tooltip="Display a table with regression statistics in the corner",
     group="Visual Settings")

tablePosition = input.string("Top Right",
     "Table Position",
     options=["Top Left", "Top Right", "Bottom Left", "Bottom Right"],
     tooltip="Position of the statistics table on chart",
     group="Visual Settings")

// ============================================================================
// CONSTANTS
// ============================================================================

// Maximum array size to prevent memory issues
// Pine Script has a 100,000 element array limit, but we cap lower for performance
var int MAX_ARRAY_SIZE = 50000

// ============================================================================
// USER-DEFINED TYPES
// ============================================================================

type Regression
    // Time coordinates (for xloc.bar_time - no lookback limit)
    int startTime
    int endTime

    // Bar indices (for Y calculation: y = slope * barIndex + intercept)
    int startBarIndex
    int endBarIndex

    // Regression parameters
    float slope
    float intercept
    float stdDev
    float pearsonR

    // State flags
    bool isLive = false
    bool isOriginal = false

    // Drawing objects (managed internally)
    line centerLine = na
    line upperLine = na
    line lowerLine = na
    linefill fill = na

// ============================================================================
// UDT METHODS
// ============================================================================

// Delete all drawing objects for this regression
method delete(Regression this) =>
    if not na(this.centerLine)
        line.delete(this.centerLine)
    if not na(this.upperLine)
        line.delete(this.upperLine)
    if not na(this.lowerLine)
        line.delete(this.lowerLine)
    if not na(this.fill)
        linefill.delete(this.fill)
    this.centerLine := na
    this.upperLine := na
    this.lowerLine := na
    this.fill := na

// Calculate Y value at a given bar index
method calculateY(Regression this, int barIdx) =>
    this.slope * barIdx + this.intercept

// Draw all regression lines using xloc.bar_time (no 5000 bar limit!)
method draw(Regression this, color baseColor, int width, float upperDev, float lowerDev, int fillTransp, bool showUpper, bool showLower) =>
    // Delete existing drawings first
    this.delete()

    // Calculate Y values at endpoints using bar indices
    startY = this.calculateY(this.startBarIndex)
    endY = this.calculateY(this.endBarIndex)

    // Determine colors
    lineColor = color.new(baseColor, 40)
    fillColor = color.new(baseColor, fillTransp)

    // Draw center line using TIME coordinates (no 5000 bar limit!)
    this.centerLine := line.new(this.startTime, startY, this.endTime, endY, xloc=xloc.bar_time, color=lineColor, width=width, style=line.style_dashed)

    // Draw upper channel if enabled
    if showUpper
        upperStartY = startY + upperDev * this.stdDev
        upperEndY = endY + upperDev * this.stdDev
        this.upperLine := line.new(this.startTime, upperStartY, this.endTime, upperEndY, xloc=xloc.bar_time, color=lineColor, width=width, style=line.style_solid)

    // Draw lower channel if enabled
    if showLower
        lowerStartY = startY - lowerDev * this.stdDev
        lowerEndY = endY - lowerDev * this.stdDev
        this.lowerLine := line.new(this.startTime, lowerStartY, this.endTime, lowerEndY, xloc=xloc.bar_time, color=lineColor, width=width, style=line.style_solid)

    // Add fill between channels if both shown
    if showUpper and showLower and not na(this.upperLine) and not na(this.lowerLine)
        this.fill := linefill.new(this.upperLine, this.lowerLine, color=fillColor)

// ============================================================================
// HELPER FUNCTIONS
// ============================================================================

// Check if current bar is within selected time range
isInRange(barTime, startT, endT) =>
    barTime >= startT and barTime <= endT


// Calculate mean of an array
calcMean(arr, size) =>
    sum = 0.0
    for i = 0 to size - 1
        sum += array.get(arr, i)
    sum / size

// Calculate standard deviation
calcStdDev(arr, mean, size) =>
    sumSquares = 0.0
    for i = 0 to size - 1
        diff = array.get(arr, i) - mean
        sumSquares += diff * diff
    math.sqrt(sumSquares / size)

// Calculate Pearson correlation coefficient with cached means
calcPearsonR(xArr, yArr, size, xMean, yMean) =>
    // Calculate covariance and standard deviations
    covariance = 0.0
    xVariance = 0.0
    yVariance = 0.0

    for i = 0 to size - 1
        xDiff = array.get(xArr, i) - xMean
        yDiff = array.get(yArr, i) - yMean
        covariance += xDiff * yDiff
        xVariance += xDiff * xDiff
        yVariance += yDiff * yDiff

    // Calculate Pearson R
    denominator = math.sqrt(xVariance * yVariance)
    pearsonR = denominator != 0 ? covariance / denominator : 0.0
    pearsonR

// Calculate linear regression parameters with cached means
calcLinearRegression(xArr, yArr, size, xMean, yMean) =>
    numerator = 0.0
    denominator = 0.0

    for i = 0 to size - 1
        xDiff = array.get(xArr, i) - xMean
        yDiff = array.get(yArr, i) - yMean
        numerator += xDiff * yDiff
        denominator += xDiff * xDiff

    slope = denominator != 0 ? numerator / denominator : 0.0
    intercept = yMean - slope * xMean

    [slope, intercept]

// ============================================================================
// CALCULATIONS
// ============================================================================

// Determine which regressions to show
showStatic = regressionMode == "Static" or regressionMode == "Both"
showLive = regressionMode == "Live" or regressionMode == "Both"

// Calculate effective price based on wick setting
// When ignoreWicks is enabled, use candle body midpoint to reduce noise from wicks
// This is more stable for regression as it filters out short-term volatility spikes
// Performance: math.avg() is a simple arithmetic operation, no performance penalty
effectivePrice = ignoreWicks ? math.avg(open, close) : priceSource

// Initialize arrays and variables for ORIGINAL regression
var array<float> origXValues = array.new<float>()
var array<float> origYValues = array.new<float>()
var float origSlope = na
var float origIntercept = na
var float origPearsonR = na
var float origStdDev = na
var int origRangeSize = 0
var int origFirstBarIndex = na
var int origLastBarIndex = na
var int origFirstTime = na
var int origLastTime = na
var bool origCalculated = false

// Initialize arrays and variables for LIVE regression
var array<float> liveXValues = array.new<float>()
var array<float> liveYValues = array.new<float>()
var float liveSlope = na
var float liveIntercept = na
var float livePearsonR = na
var float liveStdDev = na
var int liveRangeSize = 0
var int liveFirstBarIndex = na
var int liveLastBarIndex = na
var int liveFirstTime = na
var int liveLastTime = na

// Breakout tracking state variables
var bool breakoutConfirmed = false
var int breakoutBarIndex = na
var int consecutiveBreakoutBars = 0
var bool isDynamicActive = false

// Chaining state variables - track the "current" static regression for breakout detection
// This can be the original or a chained (locked) regression
var float currentStaticSlope = na
var float currentStaticIntercept = na
var float currentStaticStdDev = na
var int currentStaticFirstBar = na
var int currentStaticLastBar = na
var int currentStaticFirstTime = na
var int currentStaticLastTime = na
var float currentStaticPearsonR = na
var int chainCount = 0  // How many times we've chained (0 = original only)

// Track when dynamic R was previously above threshold (to detect the drop)
var bool wasAboveThreshold = false
var int lastBarAboveThreshold = na

// Arrays to store historical chained regressions for drawing (DEPRECATED - will be removed)
var array<float> chainedSlopes = array.new<float>()
var array<float> chainedIntercepts = array.new<float>()
var array<float> chainedStdDevs = array.new<float>()
var array<int> chainedFirstBars = array.new<int>()
var array<int> chainedLastBars = array.new<int>()
var array<float> chainedPearsonRs = array.new<float>()

// ============================================================================
// UDT-BASED STORAGE (new architecture)
// ============================================================================

// Array of all finalized (locked) regressions
var array<Regression> regressions = array.new<Regression>()

// The currently updating live regression (or na if not active)
var Regression liveRegression = na

// The original regression (first one, never removed)
var Regression originalRegression = na

// Collect data points for ORIGINAL regression (only within time range)
if isInRange(time, startTime, endTime)
    if na(origFirstBarIndex)
        origFirstBarIndex := bar_index
        origFirstTime := time
    origLastBarIndex := bar_index
    origLastTime := time

    // Prevent array overflow - only collect if under limit
    if array.size(origXValues) < MAX_ARRAY_SIZE
        array.push(origXValues, bar_index)
        array.push(origYValues, effectivePrice)
        origRangeSize := array.size(origXValues)

// Calculate ORIGINAL regression (locked once complete)
if origRangeSize >= 2 and not origCalculated
    // Cache means for performance
    origXMean = calcMean(origXValues, origRangeSize)
    origYMean = calcMean(origYValues, origRangeSize)

    [calcSlope, calcIntercept] = calcLinearRegression(origXValues, origYValues, origRangeSize, origXMean, origYMean)
    origSlope := calcSlope
    origIntercept := calcIntercept
    origPearsonR := calcPearsonR(origXValues, origYValues, origRangeSize, origXMean, origYMean)

    // Calculate standard deviation of residuals (optimized without array)
    sumSquaredResiduals = 0.0
    for i = 0 to origRangeSize - 1
        xVal = array.get(origXValues, i)
        yVal = array.get(origYValues, i)
        predicted = origSlope * xVal + origIntercept
        residual = yVal - predicted
        sumSquaredResiduals += residual * residual

    origStdDev := math.sqrt(sumSquaredResiduals / origRangeSize)

    // Mark as calculated when we're past the end time
    if time > endTime
        origCalculated := true
        // Initialize current static from original regression (first time only)
        if na(currentStaticSlope)
            currentStaticSlope := origSlope
            currentStaticIntercept := origIntercept
            currentStaticStdDev := origStdDev
            currentStaticFirstBar := origFirstBarIndex
            currentStaticLastBar := origLastBarIndex
            currentStaticFirstTime := origFirstTime
            currentStaticLastTime := origLastTime
            currentStaticPearsonR := origPearsonR

        // Create the original regression UDT (first time only)
        if na(originalRegression)
            originalRegression := Regression.new(startTime=origFirstTime, endTime=origLastTime, startBarIndex=origFirstBarIndex, endBarIndex=origLastBarIndex, slope=origSlope, intercept=origIntercept, stdDev=origStdDev, pearsonR=origPearsonR, isLive=false, isOriginal=true)

// ============================================================================
// BREAKOUT DETECTION, CHAINING, AND RESET LOGIC
// ============================================================================

// Only check for breakout/chaining after static regression is calculated
if origCalculated and showLive and not na(currentStaticSlope) and not na(currentStaticStdDev)
    // Calculate CURRENT static channel values at current bar (extended beyond original range)
    staticCurrentY = currentStaticSlope * bar_index + currentStaticIntercept
    staticUpperAtBar = staticCurrentY + upperDeviation * currentStaticStdDev
    staticLowerAtBar = staticCurrentY - lowerDeviation * currentStaticStdDev

    // Check if price is inside the current static channel
    isInsideChannel = close > staticLowerAtBar and close < staticUpperAtBar

    // =========================================================================
    // CHAINING LOGIC: Lock dynamic as new static when R drops below threshold
    // =========================================================================
    if isDynamicActive and liveRangeSize >= minBarsBeforeLock and not na(livePearsonR)
        currentAboveThreshold = math.abs(livePearsonR) >= lockRThreshold

        // Track if we were above threshold
        if currentAboveThreshold
            wasAboveThreshold := true
            lastBarAboveThreshold := bar_index

        // R dropped below threshold after being above - LOCK the dynamic as new static
        if wasAboveThreshold and not currentAboveThreshold and not na(lastBarAboveThreshold)
            // Store the current static in the chained arrays before replacing
            // Skip if chainCount=0 since original regression is already drawn separately
            if chainCount > 0
                array.push(chainedSlopes, currentStaticSlope)
                array.push(chainedIntercepts, currentStaticIntercept)
                array.push(chainedStdDevs, currentStaticStdDev)
                array.push(chainedFirstBars, currentStaticFirstBar)
                array.push(chainedLastBars, currentStaticLastBar)
                array.push(chainedPearsonRs, currentStaticPearsonR)

                // Also push to UDT array
                lockedReg = Regression.new(startTime=currentStaticFirstTime, endTime=currentStaticLastTime, startBarIndex=currentStaticFirstBar, endBarIndex=currentStaticLastBar, slope=currentStaticSlope, intercept=currentStaticIntercept, stdDev=currentStaticStdDev, pearsonR=currentStaticPearsonR, isLive=false, isOriginal=false)
                array.push(regressions, lockedReg)

            // Calculate regression values at the bar BEFORE R dropped (lastBarAboveThreshold)
            // We need to recalculate with data up to that point
            // For simplicity, we'll use the current live values but end at lastBarAboveThreshold
            lockEndBar = lastBarAboveThreshold
            lockEndTime = time[bar_index - lastBarAboveThreshold]

            // Lock the dynamic regression as the new current static
            currentStaticSlope := liveSlope
            currentStaticIntercept := liveIntercept
            currentStaticStdDev := liveStdDev
            currentStaticFirstBar := liveFirstBarIndex
            currentStaticLastBar := lockEndBar
            currentStaticFirstTime := liveFirstTime
            currentStaticLastTime := lockEndTime
            currentStaticPearsonR := livePearsonR[1]  // Use previous R (when it was still valid)
            chainCount := chainCount + 1

            // Reset dynamic state for next breakout
            breakoutConfirmed := false
            isDynamicActive := false
            consecutiveBreakoutBars := 0
            breakoutBarIndex := na
            wasAboveThreshold := false
            lastBarAboveThreshold := na

            // Clear live regression data
            array.clear(liveXValues)
            array.clear(liveYValues)
            liveSlope := na
            liveIntercept := na
            livePearsonR := na
            liveStdDev := na
            liveRangeSize := 0
            liveFirstBarIndex := na
            liveLastBarIndex := na
            liveFirstTime := na
            liveLastTime := na

            // Clear liveRegression UDT
            if not na(liveRegression)
                liveRegression.delete()
                liveRegression := na

    // =========================================================================
    // BAR-BASED TIMEOUT: Reset and restart if R threshold not reached in time
    // =========================================================================
    if isDynamicActive and not wasAboveThreshold and liveRangeSize >= maxBarsTimeout
        // Timeout reached without ever hitting R threshold
        // Store current static in chained arrays (skip if chainCount=0 to avoid duplicate of original)
        if chainCount > 0
            array.push(chainedSlopes, currentStaticSlope)
            array.push(chainedIntercepts, currentStaticIntercept)
            array.push(chainedStdDevs, currentStaticStdDev)
            array.push(chainedFirstBars, currentStaticFirstBar)
            array.push(chainedLastBars, currentStaticLastBar)
            array.push(chainedPearsonRs, currentStaticPearsonR)

            // Also push to UDT array
            lockedReg = Regression.new(startTime=currentStaticFirstTime, endTime=currentStaticLastTime, startBarIndex=currentStaticFirstBar, endBarIndex=currentStaticLastBar, slope=currentStaticSlope, intercept=currentStaticIntercept, stdDev=currentStaticStdDev, pearsonR=currentStaticPearsonR, isLive=false, isOriginal=false)
            array.push(regressions, lockedReg)

        // Start fresh regression from current bar
        // Use the live regression data as the new static (even with low R)
        currentStaticSlope := liveSlope
        currentStaticIntercept := liveIntercept
        currentStaticStdDev := liveStdDev
        currentStaticFirstBar := liveFirstBarIndex
        currentStaticLastBar := bar_index
        currentStaticFirstTime := liveFirstTime
        currentStaticLastTime := time
        currentStaticPearsonR := livePearsonR
        chainCount := chainCount + 1

        // Reset dynamic state for next breakout
        breakoutConfirmed := false
        isDynamicActive := false
        consecutiveBreakoutBars := 0
        breakoutBarIndex := na
        wasAboveThreshold := false
        lastBarAboveThreshold := na

        // Clear live regression data
        array.clear(liveXValues)
        array.clear(liveYValues)
        liveSlope := na
        liveIntercept := na
        livePearsonR := na
        liveStdDev := na
        liveRangeSize := 0
        liveFirstBarIndex := na
        liveLastBarIndex := na
        liveFirstTime := na
        liveLastTime := na

        // Clear liveRegression UDT
        if not na(liveRegression)
            liveRegression.delete()
            liveRegression := na

    // =========================================================================
    // RESET LOGIC: If dynamic is active and price returns inside channel
    // =========================================================================
    if isDynamicActive and isInsideChannel
        // Reset breakout state (but don't reset wasAboveThreshold tracking)
        breakoutConfirmed := false
        isDynamicActive := false
        consecutiveBreakoutBars := 0
        breakoutBarIndex := na
        wasAboveThreshold := false
        lastBarAboveThreshold := na
        // Clear live regression data
        array.clear(liveXValues)
        array.clear(liveYValues)
        liveSlope := na
        liveIntercept := na
        livePearsonR := na
        liveStdDev := na
        liveRangeSize := 0
        liveFirstBarIndex := na
        liveLastBarIndex := na
        liveFirstTime := na
        liveLastTime := na

        // Clear liveRegression UDT
        if not na(liveRegression)
            liveRegression.delete()
            liveRegression := na

    // =========================================================================
    // BREAKOUT DETECTION: Only if not already in dynamic mode
    // =========================================================================
    if not isDynamicActive
        // Determine breakout condition based on CURRENT static slope direction
        // Downtrend (negative slope): break above upper channel
        // Uptrend (positive slope): break below lower channel
        isBreakout = currentStaticSlope < 0 ? close > staticUpperAtBar : close < staticLowerAtBar

        if isBreakout
            consecutiveBreakoutBars := consecutiveBreakoutBars + 1
            // Check if we have enough consecutive closes to confirm
            if consecutiveBreakoutBars >= breakoutConfirmation
                breakoutConfirmed := true
                isDynamicActive := true
                // Set breakout bar to the first bar of the breakout sequence
                breakoutBarIndex := bar_index - breakoutConfirmation + 1
        else
            // Reset consecutive counter if no breakout
            consecutiveBreakoutBars := 0

// Collect data points for LIVE regression (only after breakout confirmed)
if showLive and isDynamicActive and not na(breakoutBarIndex)
    // Initialize live arrays on first collection after breakout
    if na(liveFirstBarIndex)
        liveFirstBarIndex := breakoutBarIndex
        // Get time at breakout bar (may be in the past)
        liveFirstTime := time[bar_index - breakoutBarIndex]
    liveLastBarIndex := bar_index
    liveLastTime := time

    // Add new data point
    array.push(liveXValues, bar_index)
    array.push(liveYValues, effectivePrice)

    // Implement sliding window if array gets too large
    // Remove oldest data points to maintain performance
    if array.size(liveXValues) > MAX_ARRAY_SIZE
        array.shift(liveXValues)
        array.shift(liveYValues)
        // Update first bar index to reflect removed data
        liveFirstBarIndex := int(array.get(liveXValues, 0))
        // Also update first time (approximate - use current minus offset)
        liveFirstTime := time[bar_index - liveFirstBarIndex]

    liveRangeSize := array.size(liveXValues)

// Calculate LIVE regression (updates every bar when dynamic is active)
if showLive and isDynamicActive and liveRangeSize >= 2
    // Cache means for performance
    liveXMean = calcMean(liveXValues, liveRangeSize)
    liveYMean = calcMean(liveYValues, liveRangeSize)

    [calcSlope, calcIntercept] = calcLinearRegression(liveXValues, liveYValues, liveRangeSize, liveXMean, liveYMean)
    liveSlope := calcSlope
    liveIntercept := calcIntercept
    livePearsonR := calcPearsonR(liveXValues, liveYValues, liveRangeSize, liveXMean, liveYMean)

    // Calculate standard deviation of residuals (optimized without array)
    sumSquaredLiveResiduals = 0.0
    for i = 0 to liveRangeSize - 1
        xVal = array.get(liveXValues, i)
        yVal = array.get(liveYValues, i)
        predicted = liveSlope * xVal + liveIntercept
        residual = yVal - predicted
        sumSquaredLiveResiduals += residual * residual

    liveStdDev := math.sqrt(sumSquaredLiveResiduals / liveRangeSize)

    // Create or update the liveRegression UDT
    if na(liveRegression)
        liveRegression := Regression.new(startTime=liveFirstTime, endTime=liveLastTime, startBarIndex=liveFirstBarIndex, endBarIndex=liveLastBarIndex, slope=liveSlope, intercept=liveIntercept, stdDev=liveStdDev, pearsonR=livePearsonR, isLive=true, isOriginal=false)
    else
        liveRegression.startTime := liveFirstTime
        liveRegression.endTime := liveLastTime
        liveRegression.startBarIndex := liveFirstBarIndex
        liveRegression.endBarIndex := liveLastBarIndex
        liveRegression.slope := liveSlope
        liveRegression.intercept := liveIntercept
        liveRegression.stdDev := liveStdDev
        liveRegression.pearsonR := livePearsonR

// ============================================================================
// STRATEGY ORDERS
// ============================================================================

// Track breakout direction for entries
// Downtrend breakout (slope < 0, break above) = LONG
// Uptrend breakout (slope >= 0, break below) = SHORT
var int lastBreakoutDirection = 0  // 1 = long, -1 = short, 0 = none

// Detect new breakout (transition from not active to active)
newBreakout = isDynamicActive and not isDynamicActive[1]

// Determine direction based on the static slope at time of breakout
if newBreakout and not na(currentStaticSlope)
    // If static was downtrend (negative slope), breakout is upward = LONG
    // If static was uptrend (positive slope), breakout is downward = SHORT
    lastBreakoutDirection := currentStaticSlope < 0 ? 1 : -1

// Execute strategy orders
if enableStrategy and newBreakout
    if lastBreakoutDirection == 1
        // LONG entry - close any existing short first
        if strategy.position_size < 0
            strategy.close("Short", comment="ReverseToLong")
        strategy.entry("Long", strategy.long, comment="LongEntry")
        strategy.exit("Long TP/SL", "Long",
             profit=takeProfitPoints / syminfo.mintick,
             loss=stopLossPoints / syminfo.mintick,
             comment_profit="LongTP",
             comment_loss="LongSL")
    else if lastBreakoutDirection == -1
        // SHORT entry - close any existing long first
        if strategy.position_size > 0
            strategy.close("Long", comment="ReverseToShort")
        strategy.entry("Short", strategy.short, comment="ShortEntry")
        strategy.exit("Short TP/SL", "Short",
             profit=takeProfitPoints / syminfo.mintick,
             loss=stopLossPoints / syminfo.mintick,
             comment_profit="ShortTP",
             comment_loss="ShortSL")

// ============================================================================
// DRAWING LINES (UDT-based with xloc.bar_time - no 5000 bar limit!)
// ============================================================================

// Use condition that works in both live and replay modes
shouldRedraw = barstate.islast or barstate.isconfirmed

// Delete all existing drawings when redrawing
if shouldRedraw
    // Delete original regression drawings
    if not na(originalRegression)
        originalRegression.delete()

    // Delete all chained regression drawings
    for reg in regressions
        reg.delete()

    // Delete live regression drawings
    if not na(liveRegression)
        liveRegression.delete()

// Draw ORIGINAL regression using UDT method
if showStatic and not na(originalRegression) and shouldRedraw
    baseColor = originalRegression.slope >= 0 ? uptrendColor : downtrendColor
    originalRegression.draw(baseColor, lineWidth, upperDeviation, lowerDeviation, fillTransparency, showUpperChannel, showLowerChannel)

// Draw all CHAINED regressions using UDT method
if showStatic and shouldRedraw and array.size(regressions) > 0
    for reg in regressions
        baseColor = reg.slope >= 0 ? uptrendColor : downtrendColor
        reg.draw(baseColor, lineWidth, upperDeviation, lowerDeviation, fillTransparency, showUpperChannel, showLowerChannel)

// Draw CURRENT STATIC regression (the most recent locked regression)
// This draws using the old variables temporarily until we can fully migrate
if showStatic and shouldRedraw and chainCount > 0 and not na(currentStaticSlope) and not na(currentStaticFirstTime)
    // Create a temporary Regression for drawing
    csReg = Regression.new(startTime=currentStaticFirstTime, endTime=currentStaticLastTime, startBarIndex=currentStaticFirstBar, endBarIndex=currentStaticLastBar, slope=currentStaticSlope, intercept=currentStaticIntercept, stdDev=currentStaticStdDev, pearsonR=currentStaticPearsonR, isLive=false, isOriginal=false)
    baseColor = csReg.slope >= 0 ? uptrendColor : downtrendColor
    csReg.draw(baseColor, lineWidth, upperDeviation, lowerDeviation, fillTransparency, showUpperChannel, showLowerChannel)

// Draw LIVE regression using UDT method
if showLive and isDynamicActive and not na(liveRegression) and shouldRedraw
    baseColor = liveRegression.slope >= 0 ? uptrendColor : downtrendColor
    liveRegression.draw(baseColor, lineWidth, upperDeviation, lowerDeviation, fillTransparency, showUpperChannel, showLowerChannel)


// ============================================================================
// ALERTS
// ============================================================================

// Alert when correlation is strong
strongCorrelation = showStatic and origRangeSize >= 2 and math.abs(origPearsonR) >= 0.8
liveStrongCorrelation = showLive and isDynamicActive and liveRangeSize >= 2 and math.abs(livePearsonR) >= 0.8

alertcondition(strongCorrelation,
     title="Strong Correlation Detected (Original)",
     message="Original Pearson R = {{plot_0}}")

alertcondition(liveStrongCorrelation,
     title="Strong Correlation Detected (Live)",
     message="Live Pearson R = {{plot_1}}")

// Alert when breakout is confirmed (dynamic regression starts)
breakoutJustConfirmed = isDynamicActive and isDynamicActive != isDynamicActive[1]
alertcondition(breakoutJustConfirmed,
     title="Breakout Confirmed - Dynamic Regression Started",
     message="Price broke out of static channel. Dynamic regression now active.")

// Alert when a new chain is created (dynamic locked as new static)
chainJustCreated = chainCount > chainCount[1]
alertcondition(chainJustCreated,
     title="New Chain Created - Dynamic Locked as Static",
     message="Dynamic regression R dropped below threshold. Locked as new static regression.")

// Strategy entry alerts
longEntry = enableStrategy and newBreakout and lastBreakoutDirection == 1
shortEntry = enableStrategy and newBreakout and lastBreakoutDirection == -1

alertcondition(longEntry,
     title="Long Entry Signal",
     message="Breakout LONG entry triggered. Price broke above downtrend channel.")

alertcondition(shortEntry,
     title="Short Entry Signal",
     message="Breakout SHORT entry triggered. Price broke below uptrend channel.")

// ============================================================================
// PLOT OUTPUT VALUES (for debugging and alerts)
// ============================================================================

plot(origPearsonR,
     title="Original Pearson R",
     display=display.data_window)

plot(livePearsonR,
     title="Live Pearson R",
     display=display.data_window)

plot(origSlope,
     title="Original Slope",
     display=display.data_window)

plot(liveSlope,
     title="Live Slope",
     display=display.data_window)

plot(origRangeSize,
     title="Original Sample Size",
     display=display.data_window)

plot(liveRangeSize,
     title="Live Sample Size",
     display=display.data_window)

plot(isDynamicActive ? 1 : 0,
     title="Dynamic Active",
     display=display.data_window)

plot(consecutiveBreakoutBars,
     title="Consecutive Breakout Bars",
     display=display.data_window)

plot(chainCount,
     title="Chain Count",
     display=display.data_window)

plot(wasAboveThreshold ? 1 : 0,
     title="Was Above R Threshold",
     display=display.data_window)

plot(lastBreakoutDirection,
     title="Last Breakout Direction (1=Long, -1=Short)",
     display=display.data_window)

// ============================================================================
// STATISTICS TABLE
// ============================================================================

// Delete previous table
var table statsTable = na
if not na(statsTable)
    table.delete(statsTable)

// Create statistics table if enabled
if showStatsTable and shouldRedraw and (origRangeSize >= 2 or liveRangeSize >= 2)
    // Determine table position
    tablePos = tablePosition == "Top Left" ? position.top_left :
               tablePosition == "Top Right" ? position.top_right :
               tablePosition == "Bottom Left" ? position.bottom_left :
               position.bottom_right

    // Calculate table rows based on what's being displayed
    // Base: 1 title + 4 stats per regression + 1 separator (when showing both)
    hasStaticData = showStatic and origRangeSize >= 2
    hasLiveData = showLive and isDynamicActive and liveRangeSize >= 2

    rows = if hasStaticData and hasLiveData
        9  // Title + Static header + 4 stats + Live header + 4 stats
    else if hasStaticData or hasLiveData
        5  // Title + 4 stats
    else
        2  // Title + error message

    statsTable := table.new(tablePos, 2, rows,
                           bgcolor=color.new(color.black, 85),
                           border_width=1,
                           border_color=color.new(color.gray, 50))

    // Title
    titleText = regressionMode == "Static" ? "Static Regression" : regressionMode == "Live" ? "Live Regression" : "Regression Statistics"
    table.cell(statsTable, 0, 0, titleText,
              text_color=color.white, text_size=size.normal,
              bgcolor=color.new(#2962FF, 70))
    table.merge_cells(statsTable, 0, 0, 1, 0)

    row = 1

    // Original regression stats (if showing static)
    if showStatic and origRangeSize >= 2
        if regressionMode == "Both"
            table.cell(statsTable, 0, row, "Original",
                      text_color=color.new(color.white, 30), text_size=size.small,
                      bgcolor=color.new(color.black, 95))
            table.merge_cells(statsTable, 0, row, 1, row)
            row += 1

        table.cell(statsTable, 0, row, "Pearson R",
                  text_color=color.white, text_size=size.small)
        table.cell(statsTable, 1, row, str.format("{0,number,#.####}", origPearsonR),
                  text_color=color.white, text_size=size.small)

        row += 1
        table.cell(statsTable, 0, row, "R²",
                  text_color=color.white, text_size=size.small)
        table.cell(statsTable, 1, row, str.format("{0,number,#.####}", origPearsonR * origPearsonR),
                  text_color=color.white, text_size=size.small)

        row += 1
        table.cell(statsTable, 0, row, "Slope",
                  text_color=color.white, text_size=size.small)
        table.cell(statsTable, 1, row, str.format("{0,number,#.######}", origSlope),
                  text_color=color.white, text_size=size.small)

        row += 1
        table.cell(statsTable, 0, row, "Bars",
                  text_color=color.white, text_size=size.small)
        table.cell(statsTable, 1, row, str.tostring(origRangeSize),
                  text_color=color.white, text_size=size.small)

        row += 1

    // Live regression stats (if showing live and dynamic is active)
    if showLive and isDynamicActive and liveRangeSize >= 2
        if regressionMode == "Both"
            table.cell(statsTable, 0, row, "Live",
                      text_color=color.new(color.orange, 20), text_size=size.small,
                      bgcolor=color.new(color.black, 95))
            table.merge_cells(statsTable, 0, row, 1, row)
            row += 1

        table.cell(statsTable, 0, row, "Pearson R",
                  text_color=color.white, text_size=size.small)
        table.cell(statsTable, 1, row, str.format("{0,number,#.####}", livePearsonR),
                  text_color=color.white, text_size=size.small)

        row += 1
        table.cell(statsTable, 0, row, "R²",
                  text_color=color.white, text_size=size.small)
        table.cell(statsTable, 1, row, str.format("{0,number,#.####}", livePearsonR * livePearsonR),
                  text_color=color.white, text_size=size.small)

        row += 1
        table.cell(statsTable, 0, row, "Slope",
                  text_color=color.white, text_size=size.small)
        table.cell(statsTable, 1, row, str.format("{0,number,#.######}", liveSlope),
                  text_color=color.white, text_size=size.small)

        row += 1
        table.cell(statsTable, 0, row, "Bars",
                  text_color=color.white, text_size=size.small)
        table.cell(statsTable, 1, row, str.tostring(liveRangeSize),
                  text_color=color.white, text_size=size.small)

// ============================================================================
// WARNINGS AND VALIDATION
// ============================================================================

// Warning for insufficient data
var label warningLabel = na
if not na(warningLabel)
    label.delete(warningLabel)

if shouldRedraw and origRangeSize < 2 and isInRange(time, startTime, endTime)
    warningLabel := label.new(bar_index,
         high,
         text="⚠ Insufficient data for regression\nNeed at least 2 data points",
         style=label.style_label_down,
         color=color.new(color.orange, 20),
         textcolor=color.white,
         size=size.normal)

// Warning for invalid time range
if shouldRedraw and startTime >= endTime
    warningLabel := label.new(bar_index,
         high,
         text="⚠ Invalid time range\nStart time must be before end time",
         style=label.style_label_down,
         color=color.new(color.red, 20),
         textcolor=color.white,
         size=size.normal)

// Warning for array size limit reached
if shouldRedraw and (origRangeSize >= MAX_ARRAY_SIZE or liveRangeSize >= MAX_ARRAY_SIZE)
    warningLabel := label.new(bar_index,
         low,
         text="ℹ Maximum data points reached (" + str.tostring(MAX_ARRAY_SIZE) + ")\n" +
              (liveRangeSize >= MAX_ARRAY_SIZE ? "Live regression using sliding window" : "Original regression capped"),
         style=label.style_label_up,
         color=color.new(color.blue, 20),
         textcolor=color.white,
         size=size.small)
